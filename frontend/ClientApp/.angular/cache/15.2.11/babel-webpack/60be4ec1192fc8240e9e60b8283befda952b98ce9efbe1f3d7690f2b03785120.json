{"ast":null,"code":"import { CURRENCY, PERCENT, LIST_SEPARATOR, GROUP_SEPARATOR, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, POINT, EMPTY } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport groupInteger from './group-integer';\nimport round from '../common/round';\nimport { setStyleOptions, setFormatLiterals, replaceLiterals } from './utils';\nconst SHARP = \"#\";\nconst ZERO = \"0\";\nconst trailingZerosRegExp = /(\\.(?:[0-9]*[1-9])?)0+$/g;\nconst trailingPointRegExp = /\\.$/;\nconst commaRegExp = /,/g;\nfunction trimTrailingZeros(value, lastZero) {\n  let trimRegex;\n  if (lastZero === 0) {\n    trimRegex = trailingZerosRegExp;\n  } else {\n    trimRegex = new RegExp(`(\\\\.[0-9]{${lastZero}}[1-9]*)0+$`, 'g');\n  }\n  return value.replace(trimRegex, '$1').replace(trailingPointRegExp, EMPTY);\n}\nfunction roundNumber(formatOptions) {\n  let {\n    number,\n    format\n  } = formatOptions;\n  let decimalIndex = format.indexOf(POINT);\n  if (decimalIndex !== -1) {\n    const zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;\n    const sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\n    const hasZero = zeroIndex > -1;\n    const hasSharp = sharpIndex > -1;\n    let fraction = number.toString().split(\"e\");\n    if (fraction[1]) {\n      fraction = round(number, Math.abs(fraction[1]));\n    } else {\n      fraction = fraction[0];\n    }\n    fraction = fraction.split(POINT)[1] || EMPTY;\n    let precision = fraction.length;\n    let trailingZeros = -1;\n    if (!hasZero && !hasSharp) {\n      formatOptions.format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\n      decimalIndex = -1;\n      precision = 0;\n    } else if (hasZero && zeroIndex > sharpIndex) {\n      precision = zeroIndex;\n    } else if (sharpIndex > zeroIndex) {\n      if (hasSharp && precision > sharpIndex) {\n        precision = sharpIndex;\n      } else if (hasZero && precision < zeroIndex) {\n        precision = zeroIndex;\n      }\n      trailingZeros = hasZero ? zeroIndex : 0;\n    }\n    if (precision > -1) {\n      number = round(number, precision);\n      if (trailingZeros > -1) {\n        number = trimTrailingZeros(number, trailingZeros);\n      }\n    }\n  } else {\n    number = round(number);\n  }\n  if (formatOptions.negative && number * -1 >= 0 && !formatOptions.negativeZero) {\n    formatOptions.negative = false;\n  }\n  formatOptions.number = number;\n  formatOptions.decimalIndex = decimalIndex;\n}\nfunction isConstantFormat(format) {\n  return format.indexOf(SHARP) === -1 && format.indexOf(ZERO) === -1;\n}\nfunction setValueSpecificFormat(formatOptions) {\n  let {\n    number,\n    format\n  } = formatOptions;\n  format = format.split(LIST_SEPARATOR);\n  if ((formatOptions.negative || formatOptions.negativeZero) && format[1]) {\n    format = format[1];\n    formatOptions.hasNegativeFormat = true;\n  } else if (number === 0) {\n    const zeroFormat = format[2];\n    format = zeroFormat || format[0];\n    if (zeroFormat && isConstantFormat(zeroFormat)) {\n      formatOptions.constant = zeroFormat;\n    }\n  } else {\n    format = format[0];\n  }\n  formatOptions.format = format;\n}\nfunction setGroupOptions(formatOptions) {\n  formatOptions.hasGroup = formatOptions.format.indexOf(GROUP_SEPARATOR) > -1;\n  if (formatOptions.hasGroup) {\n    formatOptions.format = formatOptions.format.replace(commaRegExp, EMPTY);\n  }\n}\nfunction placeholderIndex(index1, index2, start) {\n  let index;\n  if (index1 === -1 && index2 !== -1) {\n    index = index2;\n  } else if (index1 !== -1 && index2 === -1) {\n    index = index1;\n  } else {\n    index = start ? Math.min(index1, index2) : Math.max(index1, index2);\n  }\n  return index;\n}\nfunction setPlaceholderIndices(formatOptions) {\n  const format = formatOptions.format;\n  let sharpIndex = format.indexOf(SHARP);\n  let zeroIndex = format.indexOf(ZERO);\n  let start = placeholderIndex(sharpIndex, zeroIndex, true);\n  sharpIndex = format.lastIndexOf(SHARP);\n  zeroIndex = format.lastIndexOf(ZERO);\n  let end = placeholderIndex(sharpIndex, zeroIndex);\n  if (start === format.length) {\n    end = start;\n  }\n  formatOptions.start = start;\n  formatOptions.end = end;\n  formatOptions.lastZeroIndex = zeroIndex;\n}\nfunction replaceStyleSymbols(number, style, symbol) {\n  let result = number;\n  if (style === CURRENCY || style === PERCENT) {\n    result = EMPTY;\n    for (let idx = 0, length = number.length; idx < length; idx++) {\n      let ch = number.charAt(idx);\n      result += ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER ? symbol : ch;\n    }\n  }\n  return result;\n}\nfunction replacePlaceHolders(formatOptions, info) {\n  const {\n    start,\n    end,\n    negative,\n    negativeZero,\n    format,\n    decimalIndex,\n    lastZeroIndex,\n    hasNegativeFormat,\n    hasGroup\n  } = formatOptions;\n  let number = formatOptions.number;\n  const value = number.toString().split(POINT);\n  const length = format.length;\n  const integer = value[0];\n  const fraction = value[1] || EMPTY;\n  const integerLength = integer.length;\n  let replacement = EMPTY;\n  number = format.substring(0, start);\n  if ((negative || negativeZero) && !hasNegativeFormat) {\n    number += \"-\";\n  }\n  for (let idx = start; idx < length; idx++) {\n    let ch = format.charAt(idx);\n    if (decimalIndex === -1) {\n      if (end - idx < integerLength) {\n        number += integer;\n        break;\n      }\n    } else {\n      if (lastZeroIndex !== -1 && lastZeroIndex < idx) {\n        replacement = EMPTY;\n      }\n      if (decimalIndex - idx <= integerLength && decimalIndex - idx > -1) {\n        number += integer;\n        idx = decimalIndex;\n      }\n      if (decimalIndex === idx) {\n        number += (fraction ? info.numbers.symbols.decimal : EMPTY) + fraction;\n        idx += end - decimalIndex + 1;\n        continue;\n      }\n    }\n    if (ch === ZERO) {\n      number += ch;\n      replacement = ch;\n    } else if (ch === SHARP) {\n      number += replacement;\n    }\n  }\n  if (hasGroup) {\n    number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, integerLength + start), info.numbers.decimal, info);\n  }\n  if (end >= start) {\n    number += format.substring(end + 1);\n  }\n  return number;\n}\nfunction applyCustomFormat(formatOptions, info) {\n  let number = formatOptions.number;\n  if (formatOptions.start !== -1) {\n    number = replacePlaceHolders(formatOptions, info);\n    number = replaceStyleSymbols(number, formatOptions.style, formatOptions.symbol);\n    number = replaceLiterals(number, formatOptions.literals);\n  }\n  return number;\n}\nexport default function customNumberFormat(number, format, info) {\n  const formatOptions = {\n    negative: number < 0,\n    number: Math.abs(number),\n    negativeZero: isNegativeZero(number),\n    format: format\n  };\n  setValueSpecificFormat(formatOptions);\n  if (formatOptions.constant) {\n    return formatOptions.constant;\n  }\n  setFormatLiterals(formatOptions);\n  setStyleOptions(formatOptions, info);\n  setGroupOptions(formatOptions);\n  roundNumber(formatOptions);\n  setPlaceholderIndices(formatOptions);\n  return applyCustomFormat(formatOptions, info);\n}","map":{"version":3,"names":["CURRENCY","PERCENT","LIST_SEPARATOR","GROUP_SEPARATOR","CURRENCY_PLACEHOLDER","PERCENT_PLACEHOLDER","POINT","EMPTY","isNegativeZero","groupInteger","round","setStyleOptions","setFormatLiterals","replaceLiterals","SHARP","ZERO","trailingZerosRegExp","trailingPointRegExp","commaRegExp","trimTrailingZeros","value","lastZero","trimRegex","RegExp","replace","roundNumber","formatOptions","number","format","decimalIndex","indexOf","zeroIndex","lastIndexOf","sharpIndex","hasZero","hasSharp","fraction","toString","split","Math","abs","precision","length","trailingZeros","substring","negative","negativeZero","isConstantFormat","setValueSpecificFormat","hasNegativeFormat","zeroFormat","constant","setGroupOptions","hasGroup","placeholderIndex","index1","index2","start","index","min","max","setPlaceholderIndices","end","lastZeroIndex","replaceStyleSymbols","style","symbol","result","idx","ch","charAt","replacePlaceHolders","info","integer","integerLength","replacement","numbers","symbols","decimal","applyCustomFormat","literals","customNumberFormat"],"sources":["/Users/teqnoid/Projects/teachingchannel/node_modules/@progress/kendo-intl/dist/es2015/numbers/custom-number-format.js"],"sourcesContent":["import { CURRENCY, PERCENT, LIST_SEPARATOR, GROUP_SEPARATOR, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, POINT, EMPTY } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport groupInteger from './group-integer';\nimport round from '../common/round';\nimport { setStyleOptions, setFormatLiterals, replaceLiterals } from './utils';\n\nconst SHARP = \"#\";\nconst ZERO = \"0\";\n\nconst trailingZerosRegExp = /(\\.(?:[0-9]*[1-9])?)0+$/g;\nconst trailingPointRegExp = /\\.$/;\nconst commaRegExp = /,/g;\n\nfunction trimTrailingZeros(value, lastZero) {\n    let trimRegex;\n\n    if (lastZero === 0) {\n        trimRegex = trailingZerosRegExp;\n    } else {\n        trimRegex = new RegExp(`(\\\\.[0-9]{${ lastZero }}[1-9]*)0+$`, 'g');\n    }\n\n    return value.replace(trimRegex, '$1').replace(trailingPointRegExp, EMPTY);\n}\n\nfunction roundNumber(formatOptions) {\n    let { number, format } = formatOptions;\n    let decimalIndex = format.indexOf(POINT);\n\n    if (decimalIndex !== -1) {\n        const zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;\n        const sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\n        const hasZero = zeroIndex > -1;\n        const hasSharp = sharpIndex > -1;\n        let fraction = number.toString().split(\"e\");\n\n        if (fraction[1]) {\n            fraction = round(number, Math.abs(fraction[1]));\n        } else {\n            fraction = fraction[0];\n        }\n        fraction = fraction.split(POINT)[1] || EMPTY;\n\n        let precision = fraction.length;\n        let trailingZeros = -1;\n\n        if (!hasZero && !hasSharp) {\n            formatOptions.format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\n            decimalIndex = -1;\n            precision = 0;\n        } else if (hasZero && zeroIndex > sharpIndex) {\n            precision = zeroIndex;\n        } else if (sharpIndex > zeroIndex) {\n            if (hasSharp && precision > sharpIndex) {\n                precision = sharpIndex;\n            } else if (hasZero && precision < zeroIndex) {\n                precision = zeroIndex;\n            }\n\n            trailingZeros = hasZero ? zeroIndex : 0;\n        }\n\n        if (precision > -1) {\n            number = round(number, precision);\n            if (trailingZeros > -1) {\n                number = trimTrailingZeros(number, trailingZeros);\n            }\n        }\n    } else {\n        number = round(number);\n    }\n\n    if (formatOptions.negative && (number * -1) >= 0 && !formatOptions.negativeZero) {\n        formatOptions.negative = false;\n    }\n\n    formatOptions.number = number;\n    formatOptions.decimalIndex = decimalIndex;\n}\n\nfunction isConstantFormat(format) {\n    return format.indexOf(SHARP) === -1 && format.indexOf(ZERO) === -1;\n}\n\nfunction setValueSpecificFormat(formatOptions) {\n    let { number, format } = formatOptions;\n    format = format.split(LIST_SEPARATOR);\n    if ((formatOptions.negative || formatOptions.negativeZero) && format[1]) {\n        format = format[1];\n        formatOptions.hasNegativeFormat = true;\n    } else if (number === 0) {\n        const zeroFormat = format[2];\n        format = zeroFormat || format[0];\n        if (zeroFormat && isConstantFormat(zeroFormat)) {\n            formatOptions.constant = zeroFormat;\n        }\n    } else {\n        format = format[0];\n    }\n\n    formatOptions.format = format;\n}\n\nfunction setGroupOptions(formatOptions) {\n    formatOptions.hasGroup = formatOptions.format.indexOf(GROUP_SEPARATOR) > -1;\n    if (formatOptions.hasGroup) {\n        formatOptions.format = formatOptions.format.replace(commaRegExp, EMPTY);\n    }\n}\n\nfunction placeholderIndex(index1, index2, start) {\n    let index;\n    if (index1 === -1 && index2 !== -1) {\n        index = index2;\n    } else if (index1 !== -1 && index2 === -1) {\n        index = index1;\n    } else {\n        index = start ? Math.min(index1, index2) : Math.max(index1, index2);\n    }\n    return index;\n}\n\nfunction setPlaceholderIndices(formatOptions) {\n    const format = formatOptions.format;\n    let sharpIndex = format.indexOf(SHARP);\n    let zeroIndex = format.indexOf(ZERO);\n\n    let start = placeholderIndex(sharpIndex, zeroIndex, true);\n\n    sharpIndex = format.lastIndexOf(SHARP);\n    zeroIndex = format.lastIndexOf(ZERO);\n\n    let end = placeholderIndex(sharpIndex, zeroIndex);\n\n    if (start === format.length) {\n        end = start;\n    }\n\n    formatOptions.start = start;\n    formatOptions.end = end;\n    formatOptions.lastZeroIndex = zeroIndex;\n}\n\nfunction replaceStyleSymbols(number, style, symbol) {\n    let result = number;\n    if (style === CURRENCY || style === PERCENT) {\n        result = EMPTY;\n        for (let idx = 0, length = number.length; idx < length; idx++) {\n            let ch = number.charAt(idx);\n            result += (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) ? symbol : ch;\n        }\n    }\n    return result;\n}\n\nfunction replacePlaceHolders(formatOptions, info) {\n    const { start, end, negative, negativeZero, format, decimalIndex, lastZeroIndex, hasNegativeFormat, hasGroup } = formatOptions;\n    let number = formatOptions.number;\n    const value = number.toString().split(POINT);\n    const length = format.length;\n    const integer = value[0];\n    const fraction = value[1] || EMPTY;\n    const integerLength = integer.length;\n    let replacement = EMPTY;\n\n    number = format.substring(0, start);\n\n    if ((negative || negativeZero) && !hasNegativeFormat) {\n        number += \"-\";\n    }\n\n    for (let idx = start; idx < length; idx++) {\n        let ch = format.charAt(idx);\n\n        if (decimalIndex === -1) {\n            if (end - idx < integerLength) {\n\n                number += integer;\n                break;\n            }\n        } else {\n            if (lastZeroIndex !== -1 && lastZeroIndex < idx) {\n                replacement = EMPTY;\n            }\n\n            if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {\n                number += integer;\n                idx = decimalIndex;\n            }\n\n            if (decimalIndex === idx) {\n                number += (fraction ? info.numbers.symbols.decimal : EMPTY) + fraction;\n                idx += end - decimalIndex + 1;\n                continue;\n            }\n        }\n\n        if (ch === ZERO) {\n            number += ch;\n            replacement = ch;\n        } else if (ch === SHARP) {\n            number += replacement;\n        }\n    }\n\n    if (hasGroup) {\n        number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, (integerLength + start)), info.numbers.decimal, info);\n    }\n\n    if (end >= start) {\n        number += format.substring(end + 1);\n    }\n\n    return number;\n}\n\nfunction applyCustomFormat(formatOptions, info) {\n    let number = formatOptions.number;\n    if (formatOptions.start !== -1) {\n        number = replacePlaceHolders(formatOptions, info);\n        number = replaceStyleSymbols(number, formatOptions.style, formatOptions.symbol);\n        number = replaceLiterals(number, formatOptions.literals);\n    }\n\n    return number;\n}\n\nexport default function customNumberFormat(number, format, info) {\n    const formatOptions = {\n        negative: number < 0,\n        number: Math.abs(number),\n        negativeZero: isNegativeZero(number),\n        format: format\n    };\n\n    setValueSpecificFormat(formatOptions);\n\n    if (formatOptions.constant) {\n        return formatOptions.constant;\n    }\n\n    setFormatLiterals(formatOptions);\n    setStyleOptions(formatOptions, info);\n    setGroupOptions(formatOptions);\n    roundNumber(formatOptions);\n    setPlaceholderIndices(formatOptions);\n\n    return applyCustomFormat(formatOptions, info);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}