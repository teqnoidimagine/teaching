{"ast":null,"code":"import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\nconst REMOVAL_PENALTY = 120;\nconst ADDITION_PENALTY = 20;\nconst LENGHT_DELTA = [2, 1, 5, 3, 4];\nconst LONG_LESS_PENALTY_DELTA = -2;\nconst SHORT_LESS_PENALTY_DELTA = -1;\nconst SHORT_MORE_PENALTY_DELTA = 1;\nconst LONG_MORE_PENALTY_DELTA = 2;\nconst PENALTIES = {\n  [LONG_LESS_PENALTY_DELTA.toString()]: 8,\n  [SHORT_LESS_PENALTY_DELTA.toString()]: 6,\n  [LONG_MORE_PENALTY_DELTA.toString()]: 6,\n  [SHORT_MORE_PENALTY_DELTA.toString()]: 3\n};\nconst VALUE_FORMAT_LENGTH = {\n  numeric: 1,\n  \"2-digit\": 2,\n  short: 3,\n  long: 4,\n  narrow: 5\n};\nconst TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\nfunction getHourSpecifier(options) {\n  return options.hour12 ? \"h\" : \"H\";\n}\nconst DATE_OPTIONS_MAP = [{\n  key: \"era\",\n  specifier: \"G\"\n}, {\n  key: \"year\",\n  specifier: \"y\"\n}, {\n  key: \"month\",\n  specifier: \"M\"\n}, {\n  key: \"day\",\n  specifier: \"d\"\n}, {\n  key: \"weekday\",\n  specifier: \"E\"\n}, {\n  key: \"hour\",\n  getSpecifier: getHourSpecifier\n}, {\n  key: \"minute\",\n  specifier: \"m\"\n}, {\n  key: \"second\",\n  specifier: \"s\"\n}, {\n  key: \"timeZoneName\",\n  specifier: \"z\"\n}];\nconst STAND_ALONE_SPECIFIERS = {\n  e: 'c',\n  E: 'c',\n  M: 'L',\n  Q: 'q'\n};\nconst specifiersRegex = {};\nconst resolvedFormats = {};\nfunction getSpecifierRegex(specifier) {\n  if (!specifiersRegex[specifier]) {\n    specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n  }\n  return specifiersRegex[specifier];\n}\nfunction skeletonSpecifiers(skeleton) {\n  const result = [];\n  let current = skeleton.charAt(0);\n  let specifier = current;\n  for (let idx = 1; idx < skeleton.length; idx++) {\n    let character = skeleton.charAt(idx);\n    if (character === specifier) {\n      current += character;\n    } else {\n      result.push(current);\n      current = specifier = character;\n    }\n  }\n  result.push(current);\n  return result;\n}\nfunction findBestMatch(specifiers, availableFormats) {\n  const specifiersLength = specifiers.length;\n  let maxScore = -Number.MAX_VALUE;\n  let bestMatches, result;\n  for (let format in availableFormats) {\n    const matches = [];\n    let currentFormat = format.replace(\"v\", \"z\");\n    let score = 0;\n    for (let idx = 0; idx < specifiersLength; idx++) {\n      const specifier = specifiers[idx];\n      let specifierRegex = getSpecifierRegex(specifier[0]);\n      let match = (specifierRegex.exec(currentFormat) || [])[0];\n      if (!match) {\n        score -= REMOVAL_PENALTY;\n      } else {\n        currentFormat = currentFormat.replace(match, EMPTY);\n        if (match.length !== specifier.length) {\n          let delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n          score -= PENALTIES[delta];\n        }\n      }\n      matches.push(match);\n      if (score < maxScore) {\n        break;\n      }\n    }\n    if (currentFormat.length) {\n      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n    }\n    if (score > maxScore) {\n      maxScore = score;\n      bestMatches = matches;\n      result = availableFormats[format];\n    }\n  }\n  result = result.replace(\"v\", \"z\");\n  for (let idx = 0; idx < specifiersLength; idx++) {\n    const bestMatch = bestMatches[idx];\n    if (bestMatch && bestMatch !== specifiers[idx]) {\n      const matchSpecifier = bestMatches[idx][0];\n      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx]);\n      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx]);\n      }\n    }\n  }\n  return result;\n}\nfunction cacheFormat(skeleton, format, locale) {\n  if (!resolvedFormats[locale]) {\n    resolvedFormats[locale] = {};\n  }\n  resolvedFormats[locale][skeleton] = format;\n}\nfunction skeletonFormat(skeleton, info) {\n  const availableFormats = info.calendar.dateTimeFormats.availableFormats;\n  if (availableFormats[skeleton]) {\n    return availableFormats[skeleton];\n  }\n  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n    return resolvedFormats[info.name][skeleton];\n  }\n  const timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n  let result;\n  if (timeStartIndex > 0) {\n    const dateSkeleton = skeleton.substr(0, timeStartIndex);\n    const timeSkeleton = skeleton.substr(timeStartIndex);\n    result = formatString(info.calendar.dateTimeFormats.short,\n    //should be deterimed based on specifiers\n    availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats), availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n  } else {\n    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n  }\n  cacheFormat(skeleton, result, info.name);\n  return result;\n}\nfunction skeletonFromOptions(options) {\n  let result = [];\n  for (let idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n    let option = DATE_OPTIONS_MAP[idx];\n    let field = option.key;\n    let value = options[field];\n    if (value) {\n      let spcifier = option.specifier || option.getSpecifier(options);\n      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n    }\n  }\n  return result.join(EMPTY);\n}\nexport default function datePattern(format, info) {\n  const calendar = info.calendar;\n  let result;\n  if (isString(format)) {\n    if (calendar.patterns[format]) {\n      result = calendar.patterns[format];\n    } else {\n      result = format;\n    }\n  } else if (format) {\n    if (format.pattern) {\n      return format.pattern;\n    }\n    let skeleton = format.skeleton;\n    if (!skeleton) {\n      if (format.datetime) {\n        result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n      } else if (format.date) {\n        result = calendar.dateFormats[format.date];\n      } else if (format.time) {\n        result = calendar.timeFormats[format.time];\n      } else {\n        skeleton = skeletonFromOptions(format);\n      }\n    }\n    if (skeleton) {\n      result = skeletonFormat(skeleton, info);\n    }\n  }\n  if (!result) {\n    result = calendar.patterns.d;\n  }\n  return result;\n}","map":{"version":3,"names":["formatString","isString","EMPTY","REMOVAL_PENALTY","ADDITION_PENALTY","LENGHT_DELTA","LONG_LESS_PENALTY_DELTA","SHORT_LESS_PENALTY_DELTA","SHORT_MORE_PENALTY_DELTA","LONG_MORE_PENALTY_DELTA","PENALTIES","toString","VALUE_FORMAT_LENGTH","numeric","short","long","narrow","TIME_SPECIFIERS_REGEX","getHourSpecifier","options","hour12","DATE_OPTIONS_MAP","key","specifier","getSpecifier","STAND_ALONE_SPECIFIERS","e","E","M","Q","specifiersRegex","resolvedFormats","getSpecifierRegex","RegExp","skeletonSpecifiers","skeleton","result","current","charAt","idx","length","character","push","findBestMatch","specifiers","availableFormats","specifiersLength","maxScore","Number","MAX_VALUE","bestMatches","format","matches","currentFormat","replace","score","specifierRegex","match","exec","delta","Math","max","min","bestMatch","matchSpecifier","cacheFormat","locale","skeletonFormat","info","calendar","dateTimeFormats","name","timeStartIndex","search","dateSkeleton","substr","timeSkeleton","skeletonFromOptions","option","field","value","spcifier","repeat","join","datePattern","patterns","pattern","datetime","timeFormats","dateFormats","date","time","d"],"sources":["/Users/teqnoid/Projects/teachingchannel/node_modules/@progress/kendo-intl/dist/es2015/dates/date-pattern.js"],"sourcesContent":["import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\n\nconst REMOVAL_PENALTY = 120;\nconst ADDITION_PENALTY = 20;\nconst LENGHT_DELTA = [ 2, 1, 5, 3, 4 ];\nconst LONG_LESS_PENALTY_DELTA = -2;\nconst SHORT_LESS_PENALTY_DELTA = -1;\nconst SHORT_MORE_PENALTY_DELTA = 1;\nconst LONG_MORE_PENALTY_DELTA = 2;\n\nconst PENALTIES = {\n    [LONG_LESS_PENALTY_DELTA.toString()]: 8,\n    [SHORT_LESS_PENALTY_DELTA.toString()]: 6,\n    [LONG_MORE_PENALTY_DELTA.toString()]: 6,\n    [SHORT_MORE_PENALTY_DELTA.toString()]: 3\n};\n\nconst VALUE_FORMAT_LENGTH = {\n    numeric: 1,\n    \"2-digit\": 2,\n    short: 3,\n    long: 4,\n    narrow: 5\n};\n\nconst TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n    return options.hour12 ? \"h\" : \"H\";\n}\n\nconst DATE_OPTIONS_MAP = [ {\n    key: \"era\",\n    specifier: \"G\"\n}, {\n    key: \"year\",\n    specifier: \"y\"\n}, {\n    key: \"month\",\n    specifier: \"M\"\n}, {\n    key: \"day\",\n    specifier: \"d\"\n}, {\n    key: \"weekday\",\n    specifier: \"E\"\n}, {\n    key: \"hour\",\n    getSpecifier: getHourSpecifier\n}, {\n    key: \"minute\",\n    specifier: \"m\"\n}, {\n    key: \"second\",\n    specifier: \"s\"\n}, {\n    key: \"timeZoneName\",\n    specifier: \"z\"\n} ];\n\nconst STAND_ALONE_SPECIFIERS = {\n    e: 'c',\n    E: 'c',\n    M: 'L',\n    Q: 'q'\n};\n\nconst specifiersRegex = {};\nconst resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n    if (!specifiersRegex[specifier]) {\n        specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n    }\n    return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n    const result = [];\n    let current = skeleton.charAt(0);\n    let specifier = current;\n    for (let idx = 1; idx < skeleton.length; idx++) {\n        let character = skeleton.charAt(idx);\n        if (character === specifier) {\n            current += character;\n        } else {\n            result.push(current);\n            current = specifier = character;\n        }\n    }\n\n    result.push(current);\n\n    return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n    const specifiersLength = specifiers.length;\n    let maxScore = -Number.MAX_VALUE;\n    let bestMatches, result;\n    for (let format in availableFormats) {\n        const matches = [];\n        let currentFormat = format.replace(\"v\", \"z\");\n        let score = 0;\n        for (let idx = 0; idx < specifiersLength; idx++) {\n            const specifier = specifiers[idx];\n            let specifierRegex = getSpecifierRegex(specifier[0]);\n            let match = (specifierRegex.exec(currentFormat) || [])[0];\n\n            if (!match) {\n                score -= REMOVAL_PENALTY;\n            } else {\n                currentFormat = currentFormat.replace(match, EMPTY);\n                if (match.length !== specifier.length) {\n                    let delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n                    score -= PENALTIES[delta];\n                }\n            }\n\n            matches.push(match);\n\n            if (score < maxScore) {\n                break;\n            }\n        }\n\n        if (currentFormat.length) {\n            score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n        }\n\n        if (score > maxScore) {\n            maxScore = score;\n            bestMatches = matches;\n            result = availableFormats[format];\n        }\n    }\n\n    result = result.replace(\"v\", \"z\");\n\n    for (let idx = 0; idx < specifiersLength; idx++) {\n        const bestMatch = bestMatches[idx];\n        if (bestMatch && bestMatch !== specifiers[idx]) {\n            const matchSpecifier = bestMatches[idx][0];\n            result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx]);\n            if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n                result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx]);\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n    if (!resolvedFormats[locale]) {\n        resolvedFormats[locale] = {};\n    }\n    resolvedFormats[locale][skeleton] = format;\n}\n\n\nfunction skeletonFormat(skeleton, info) {\n    const availableFormats = info.calendar.dateTimeFormats.availableFormats;\n    if (availableFormats[skeleton]) {\n        return availableFormats[skeleton];\n    }\n    if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n        return resolvedFormats[info.name][skeleton];\n    }\n    const timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n    let result;\n    if (timeStartIndex > 0) {\n        const dateSkeleton = skeleton.substr(0, timeStartIndex);\n        const timeSkeleton = skeleton.substr(timeStartIndex);\n\n        result = formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n            availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),\n            availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n    } else {\n        result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n    }\n\n    cacheFormat(skeleton, result, info.name);\n    return result;\n}\n\nfunction skeletonFromOptions(options) {\n    let result = [];\n    for (let idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n        let option = DATE_OPTIONS_MAP[idx];\n        let field = option.key;\n        let value = options[field];\n        if (value) {\n            let spcifier = option.specifier || option.getSpecifier(options);\n            result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n        }\n    }\n\n    return result.join(EMPTY);\n}\n\nexport default function datePattern(format, info) {\n    const calendar = info.calendar;\n    let result;\n    if (isString(format)) {\n        if (calendar.patterns[format]) {\n            result = calendar.patterns[format];\n        } else {\n            result = format;\n        }\n    } else if (format) {\n        if (format.pattern) {\n            return format.pattern;\n        }\n\n        let skeleton = format.skeleton;\n        if (!skeleton) {\n            if (format.datetime) {\n                result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n            } else if (format.date) {\n                result = calendar.dateFormats[format.date];\n            } else if (format.time) {\n                result = calendar.timeFormats[format.time];\n            } else {\n                skeleton = skeletonFromOptions(format);\n            }\n        }\n\n        if (skeleton) {\n            result = skeletonFormat(skeleton, info);\n        }\n    }\n\n    if (!result) {\n        result = calendar.patterns.d;\n    }\n\n    return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}