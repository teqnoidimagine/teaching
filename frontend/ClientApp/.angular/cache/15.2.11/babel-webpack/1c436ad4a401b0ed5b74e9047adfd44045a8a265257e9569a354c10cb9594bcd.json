{"ast":null,"code":"import { PERCENT, SCIENTIFIC, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, EMPTY, POINT } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport formatCurrencySymbol from './format-currency-symbol';\nimport groupInteger from './group-integer';\nimport isCurrencyStyle from './is-currency-style';\nimport pad from '../common/pad';\nimport round from '../common/round';\nimport { currencyFractionOptions } from '../cldr';\nconst DEFAULT_DECIMAL_ROUNDING = 3;\nconst DEFAULT_PERCENT_ROUNDING = 0;\nconst trailingZeroRegex = /0+$/;\nfunction fractionOptions(options) {\n  let {\n    minimumFractionDigits,\n    maximumFractionDigits,\n    style\n  } = options;\n  const isCurrency = isCurrencyStyle(style);\n  let currencyFractions;\n  if (isCurrency) {\n    currencyFractions = currencyFractionOptions(options.currency);\n  }\n  if (minimumFractionDigits === undefined) {\n    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n  }\n  if (maximumFractionDigits === undefined) {\n    if (style === PERCENT) {\n      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n    } else if (isCurrency) {\n      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n    } else {\n      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n    }\n  }\n  return {\n    minimumFractionDigits: minimumFractionDigits,\n    maximumFractionDigits: maximumFractionDigits\n  };\n}\nfunction applyPattern(value, pattern, symbol) {\n  let result = EMPTY;\n  for (let idx = 0, length = pattern.length; idx < length; idx++) {\n    let ch = pattern.charAt(idx);\n    if (ch === NUMBER_PLACEHOLDER) {\n      result += value;\n    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n      result += symbol;\n    } else {\n      result += ch;\n    }\n  }\n  return result;\n}\nfunction currencyUnitPattern(info, value) {\n  const currencyInfo = info.numbers.currency;\n  let pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n  if (value < 0) {\n    pattern = pattern.replace(NUMBER_PLACEHOLDER, `-${NUMBER_PLACEHOLDER}`);\n  }\n  return pattern;\n}\nexport default function standardNumberFormat(number, options, info) {\n  const symbols = info.numbers.symbols;\n  const {\n    style\n  } = options;\n  const isCurrency = isCurrencyStyle(style);\n\n  //return number in exponential format\n  if (style === SCIENTIFIC) {\n    let exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n    return exponential.replace(POINT, symbols.decimal);\n  }\n  let value = number;\n  let symbol;\n  if (isCurrency) {\n    options.value = value;\n    symbol = formatCurrencySymbol(info, options);\n  }\n  if (style === PERCENT) {\n    value *= 100;\n    symbol = symbols.percentSign;\n  }\n  const {\n    minimumFractionDigits,\n    maximumFractionDigits\n  } = fractionOptions(options);\n  value = round(value, maximumFractionDigits);\n  const negative = value < 0;\n  const negativeZero = isNegativeZero(number);\n  const parts = value.split(POINT);\n  let integer = parts[0];\n  let fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);\n\n  //exclude \"-\" if number is negative.\n  if (negative) {\n    integer = integer.substring(1);\n  }\n  if (options.minimumIntegerDigits) {\n    integer = pad(integer, options.minimumIntegerDigits);\n  }\n  let formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n  if (fraction) {\n    formattedValue += symbols.decimal + fraction;\n  }\n  let pattern;\n  if (isCurrency && options.currencyDisplay === \"name\") {\n    pattern = currencyUnitPattern(info, number);\n  } else {\n    const patterns = options.patterns;\n    pattern = negative || negativeZero ? patterns[1] || \"-\" + patterns[0] : patterns[0];\n  }\n  if (pattern === NUMBER_PLACEHOLDER && !negative) {\n    return formattedValue;\n  }\n  const result = applyPattern(formattedValue, pattern, symbol);\n  return result;\n}","map":{"version":3,"names":["PERCENT","SCIENTIFIC","NUMBER_PLACEHOLDER","CURRENCY_PLACEHOLDER","PERCENT_PLACEHOLDER","EMPTY","POINT","isNegativeZero","formatCurrencySymbol","groupInteger","isCurrencyStyle","pad","round","currencyFractionOptions","DEFAULT_DECIMAL_ROUNDING","DEFAULT_PERCENT_ROUNDING","trailingZeroRegex","fractionOptions","options","minimumFractionDigits","maximumFractionDigits","style","isCurrency","currencyFractions","currency","undefined","Math","max","applyPattern","value","pattern","symbol","result","idx","length","ch","charAt","currencyUnitPattern","info","currencyInfo","numbers","replace","standardNumberFormat","number","symbols","exponential","toExponential","decimal","percentSign","negative","negativeZero","parts","split","integer","fraction","substring","minimumIntegerDigits","formattedValue","useGrouping","currencyDisplay","patterns"],"sources":["/Users/teqnoid/Projects/teachingchannel/node_modules/@progress/kendo-intl/dist/es2015/numbers/standard-number-format.js"],"sourcesContent":["import { PERCENT, SCIENTIFIC, NUMBER_PLACEHOLDER, CURRENCY_PLACEHOLDER, PERCENT_PLACEHOLDER, EMPTY, POINT } from '../common/constants';\nimport isNegativeZero from '../common/is-negative-zero';\nimport formatCurrencySymbol from './format-currency-symbol';\nimport groupInteger from './group-integer';\nimport isCurrencyStyle from './is-currency-style';\nimport pad from '../common/pad';\nimport round from '../common/round';\nimport { currencyFractionOptions } from '../cldr';\n\nconst DEFAULT_DECIMAL_ROUNDING = 3;\nconst DEFAULT_PERCENT_ROUNDING = 0;\n\nconst trailingZeroRegex = /0+$/;\n\nfunction fractionOptions(options) {\n    let { minimumFractionDigits, maximumFractionDigits, style } = options;\n    const isCurrency = isCurrencyStyle(style);\n    let currencyFractions;\n    if (isCurrency) {\n        currencyFractions = currencyFractionOptions(options.currency);\n    }\n\n    if (minimumFractionDigits === undefined) {\n        minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;\n    }\n\n    if (maximumFractionDigits === undefined) {\n        if (style === PERCENT) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);\n        } else if (isCurrency) {\n            maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);\n        } else {\n            maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);\n        }\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nfunction applyPattern(value, pattern, symbol) {\n    let result = EMPTY;\n    for (let idx = 0, length = pattern.length; idx < length; idx++) {\n        let ch = pattern.charAt(idx);\n\n        if (ch === NUMBER_PLACEHOLDER) {\n            result += value;\n        } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {\n            result += symbol;\n        } else {\n            result += ch;\n        }\n    }\n    return result;\n}\n\nfunction currencyUnitPattern(info, value) {\n    const currencyInfo = info.numbers.currency;\n    let pattern = value !== 1 ? currencyInfo[\"unitPattern-count-other\"] : currencyInfo[\"unitPattern-count-one\"];\n    if (value < 0) {\n        pattern = pattern.replace(NUMBER_PLACEHOLDER, `-${ NUMBER_PLACEHOLDER }`);\n    }\n\n    return pattern;\n}\n\n\nexport default function standardNumberFormat(number, options, info) {\n    const symbols = info.numbers.symbols;\n    const { style } = options;\n    const isCurrency = isCurrencyStyle(style);\n\n    //return number in exponential format\n    if (style === SCIENTIFIC) {\n        let exponential = options.minimumFractionDigits !== undefined ? number.toExponential(options.minimumFractionDigits) : number.toExponential();\n        return exponential.replace(POINT, symbols.decimal);\n    }\n\n    let value = number;\n    let symbol;\n\n    if (isCurrency) {\n        options.value = value;\n        symbol = formatCurrencySymbol(info, options);\n    }\n\n    if (style === PERCENT) {\n        value *= 100;\n        symbol = symbols.percentSign;\n    }\n\n    const { minimumFractionDigits, maximumFractionDigits } = fractionOptions(options);\n\n    value = round(value, maximumFractionDigits);\n\n    const negative = value < 0;\n    const negativeZero = isNegativeZero(number);\n\n    const parts = value.split(POINT);\n\n    let integer = parts[0];\n    let fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);\n\n    //exclude \"-\" if number is negative.\n    if (negative) {\n        integer = integer.substring(1);\n    }\n\n    if (options.minimumIntegerDigits) {\n        integer = pad(integer, options.minimumIntegerDigits);\n    }\n\n    let formattedValue = options.useGrouping !== false ? groupInteger(integer, 0, integer.length, options, info) : integer;\n\n    if (fraction) {\n        formattedValue += symbols.decimal + fraction;\n    }\n\n    let pattern;\n\n    if (isCurrency && options.currencyDisplay === \"name\") {\n        pattern = currencyUnitPattern(info, number);\n    } else {\n        const patterns = options.patterns;\n        pattern = (negative || negativeZero) ? patterns[1] || (\"-\" + patterns[0]) : patterns[0];\n    }\n\n    if (pattern === NUMBER_PLACEHOLDER && !negative) {\n        return formattedValue;\n    }\n\n    const result = applyPattern(formattedValue, pattern, symbol);\n\n    return result;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}