{"ast":null,"code":"import { cldr, getLocaleInfo } from './info';\nimport { errors } from '../errors';\nimport localeTerritory from './territory';\nimport parseRangeDate from './parse-range-date';\n\n/* eslint-disable consistent-return */\n\nconst {\n  NoCurrency,\n  NoCurrencyDisplay,\n  NoSupplementalCurrency,\n  NoCurrencyRegion,\n  NoValidCurrency\n} = errors;\nconst DEFAULT_CURRENCY_FRACTIONS = 2;\nconst SYMBOL = \"symbol\";\nconst INVALID_CURRENCY_CODE = 'XXX';\nconst GLOBAL_CURRENCIES = {\n  '001': 'USD',\n  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error\n  '150': 'EUR' // 150 territory for Europe\n};\n\nfunction getCurrencyInfo(locale, currency, throwIfNoValid) {\n  const info = getLocaleInfo(locale);\n  const currencies = info.numbers.currencies;\n  if (!currencies) {\n    if (throwIfNoValid) {\n      throw NoCurrency.error();\n    }\n    return;\n  }\n  const currencyDisplayInfo = currencies[currency];\n  if (!currencyDisplayInfo) {\n    if (throwIfNoValid) {\n      throw NoCurrencyDisplay.error();\n    }\n    return;\n  }\n  return currencyDisplayInfo;\n}\nfunction lengthComparer(a, b) {\n  return b.length - a.length;\n}\nfunction regionCurrency(regionCurrencies) {\n  let latestValidUntil, latestValidUntilRange;\n  let latestStillValid, latestStillValidDate;\n  for (let idx = 0; idx < regionCurrencies.length; idx++) {\n    const currency = regionCurrencies[idx];\n    const code = Object.keys(currency)[0];\n    const info = currency[code];\n    if (code !== INVALID_CURRENCY_CODE && info._tender !== 'false' && info._from) {\n      if (!info._to) {\n        const stillValidDate = parseRangeDate(info._from);\n        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {\n          latestStillValid = code;\n          latestStillValidDate = stillValidDate;\n        }\n      } else if (!latestStillValid) {\n        const validFrom = parseRangeDate(info._from);\n        const validTo = parseRangeDate(info._to);\n        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {\n          latestValidUntil = code;\n          latestValidUntilRange = {\n            from: validFrom,\n            to: validTo\n          };\n        }\n      }\n    }\n  }\n  return latestStillValid || latestValidUntil;\n}\nexport function currencyDisplays(locale, currency, throwIfNoValid = true) {\n  const currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);\n  if (!currencyInfo) {\n    return;\n  }\n  if (!currencyInfo.displays) {\n    const displays = [currency];\n    for (let field in currencyInfo) {\n      displays.push(currencyInfo[field]);\n    }\n    displays.sort(lengthComparer);\n    currencyInfo.displays = displays;\n  }\n  return currencyInfo.displays;\n}\nexport function currencyDisplay(locale, options) {\n  const {\n    value,\n    currency,\n    currencyDisplay = SYMBOL\n  } = options;\n  if (currencyDisplay === \"code\") {\n    return currency;\n  }\n  const currencyInfo = getCurrencyInfo(locale, currency, true);\n  let result;\n  if (currencyDisplay === SYMBOL) {\n    result = currencyInfo[\"symbol-alt-narrow\"] || currencyInfo[SYMBOL] || currency;\n  } else {\n    if (typeof value === \"undefined\" || value !== 1) {\n      result = currencyInfo[\"displayName-count-other\"];\n    } else {\n      result = currencyInfo[\"displayName-count-one\"];\n    }\n  }\n  return result;\n}\nexport function currencyFractionOptions(code) {\n  let minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n  let maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n  const fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];\n  if (fractions && fractions._digits) {\n    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);\n  }\n  return {\n    minimumFractionDigits: minimumFractionDigits,\n    maximumFractionDigits: maximumFractionDigits\n  };\n}\nexport function territoryCurrencyCode(territory, throwIfNoValid = true) {\n  if (GLOBAL_CURRENCIES[territory]) {\n    return GLOBAL_CURRENCIES[territory];\n  }\n  const currencyData = cldr.supplemental.currencyData;\n  if (!currencyData) {\n    if (throwIfNoValid) {\n      throw NoSupplementalCurrency.error();\n    }\n    return;\n  }\n  const regionCurrencies = currencyData.region[territory];\n  if (!regionCurrencies) {\n    if (throwIfNoValid) {\n      throw NoCurrencyRegion.error(territory);\n    }\n    return;\n  }\n  const currencyCode = regionCurrency(regionCurrencies);\n  return currencyCode;\n}\nexport function localeCurrency(locale, throwIfNoValid) {\n  const info = getLocaleInfo(locale);\n  const numbers = info.numbers;\n  if (!numbers.localeCurrency) {\n    const currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);\n    if (!currency && throwIfNoValid) {\n      throw NoValidCurrency.error(info.name);\n    }\n    numbers.localeCurrency = currency;\n  }\n  return numbers.localeCurrency;\n}","map":{"version":3,"names":["cldr","getLocaleInfo","errors","localeTerritory","parseRangeDate","NoCurrency","NoCurrencyDisplay","NoSupplementalCurrency","NoCurrencyRegion","NoValidCurrency","DEFAULT_CURRENCY_FRACTIONS","SYMBOL","INVALID_CURRENCY_CODE","GLOBAL_CURRENCIES","getCurrencyInfo","locale","currency","throwIfNoValid","info","currencies","numbers","error","currencyDisplayInfo","lengthComparer","a","b","length","regionCurrency","regionCurrencies","latestValidUntil","latestValidUntilRange","latestStillValid","latestStillValidDate","idx","code","Object","keys","_tender","_from","_to","stillValidDate","validFrom","validTo","to","from","currencyDisplays","currencyInfo","displays","field","push","sort","currencyDisplay","options","value","result","currencyFractionOptions","minimumFractionDigits","maximumFractionDigits","fractions","supplemental","currencyData","_digits","parseInt","territoryCurrencyCode","territory","region","currencyCode","localeCurrency","name"],"sources":["/Users/teqnoid/Projects/teachingchannel/node_modules/@progress/kendo-intl/dist/es2015/cldr/currency.js"],"sourcesContent":["import { cldr, getLocaleInfo } from './info';\nimport { errors } from '../errors';\nimport localeTerritory from './territory';\nimport parseRangeDate from './parse-range-date';\n\n/* eslint-disable consistent-return */\n\nconst {\n    NoCurrency,\n    NoCurrencyDisplay,\n    NoSupplementalCurrency,\n    NoCurrencyRegion,\n    NoValidCurrency\n} = errors;\n\nconst DEFAULT_CURRENCY_FRACTIONS = 2;\nconst SYMBOL = \"symbol\";\nconst INVALID_CURRENCY_CODE = 'XXX';\n\nconst GLOBAL_CURRENCIES = {\n    '001': 'USD', // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error\n    '150': 'EUR' // 150 territory for Europe\n\n};\n\nfunction getCurrencyInfo(locale, currency, throwIfNoValid) {\n    const info = getLocaleInfo(locale);\n    const currencies = info.numbers.currencies;\n    if (!currencies) {\n        if (throwIfNoValid) {\n            throw NoCurrency.error();\n        }\n\n        return;\n    }\n\n    const currencyDisplayInfo = currencies[currency];\n\n    if (!currencyDisplayInfo) {\n        if (throwIfNoValid) {\n            throw NoCurrencyDisplay.error();\n        }\n\n        return;\n    }\n\n    return currencyDisplayInfo;\n}\n\nfunction lengthComparer(a, b) {\n    return b.length - a.length;\n}\n\nfunction regionCurrency(regionCurrencies) {\n    let latestValidUntil, latestValidUntilRange;\n    let latestStillValid, latestStillValidDate;\n\n    for (let idx = 0; idx < regionCurrencies.length; idx++) {\n        const currency = regionCurrencies[idx];\n        const code = Object.keys(currency)[0];\n        const info = currency[code];\n        if (code !== INVALID_CURRENCY_CODE && info._tender !== 'false' && info._from) {\n            if (!info._to) {\n                const stillValidDate = parseRangeDate(info._from);\n                if (!latestStillValidDate || latestStillValidDate < stillValidDate) {\n                    latestStillValid = code;\n                    latestStillValidDate = stillValidDate;\n                }\n            } else if (!latestStillValid) {\n                const validFrom = parseRangeDate(info._from);\n                const validTo = parseRangeDate(info._to);\n                if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {\n                    latestValidUntil = code;\n                    latestValidUntilRange = {\n                        from: validFrom,\n                        to: validTo\n                    };\n                }\n            }\n        }\n    }\n\n    return latestStillValid || latestValidUntil;\n}\n\nexport function currencyDisplays(locale, currency, throwIfNoValid = true) {\n    const currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);\n    if (!currencyInfo) {\n        return;\n    }\n\n    if (!currencyInfo.displays) {\n        const displays = [ currency ];\n        for (let field in currencyInfo) {\n            displays.push(currencyInfo[field]);\n        }\n        displays.sort(lengthComparer);\n        currencyInfo.displays = displays;\n    }\n\n    return currencyInfo.displays;\n}\n\nexport function currencyDisplay(locale, options) {\n    const { value, currency, currencyDisplay = SYMBOL } = options;\n\n    if (currencyDisplay === \"code\") {\n        return currency;\n    }\n\n    const currencyInfo = getCurrencyInfo(locale, currency, true);\n    let result;\n\n    if (currencyDisplay === SYMBOL) {\n        result = currencyInfo[\"symbol-alt-narrow\"] || currencyInfo[SYMBOL] || currency;\n    } else {\n        if (typeof value === \"undefined\" || value !== 1) {\n            result = currencyInfo[\"displayName-count-other\"];\n        } else {\n            result = currencyInfo[\"displayName-count-one\"];\n        }\n    }\n\n    return result;\n}\n\nexport function currencyFractionOptions(code) {\n    let minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n    let maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;\n\n    const fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];\n\n    if (fractions && fractions._digits) {\n        maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);\n    }\n\n    return {\n        minimumFractionDigits: minimumFractionDigits,\n        maximumFractionDigits: maximumFractionDigits\n    };\n}\n\nexport function territoryCurrencyCode(territory, throwIfNoValid = true) {\n    if (GLOBAL_CURRENCIES[territory]) {\n        return GLOBAL_CURRENCIES[territory];\n    }\n\n    const currencyData = cldr.supplemental.currencyData;\n    if (!currencyData) {\n        if (throwIfNoValid) {\n            throw NoSupplementalCurrency.error();\n        }\n\n        return;\n    }\n\n    const regionCurrencies = currencyData.region[territory];\n\n    if (!regionCurrencies) {\n        if (throwIfNoValid) {\n            throw NoCurrencyRegion.error(territory);\n        }\n\n        return;\n    }\n\n    const currencyCode = regionCurrency(regionCurrencies);\n\n    return currencyCode;\n}\n\nexport function localeCurrency(locale, throwIfNoValid) {\n    const info = getLocaleInfo(locale);\n    const numbers = info.numbers;\n\n    if (!numbers.localeCurrency) {\n        const currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);\n\n        if (!currency && throwIfNoValid) {\n            throw NoValidCurrency.error(info.name);\n        }\n\n        numbers.localeCurrency = currency;\n    }\n\n    return numbers.localeCurrency;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}